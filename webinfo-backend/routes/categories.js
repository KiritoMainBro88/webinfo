// routes/categories.js
const express = require('express');
const Category = require('../models/Category');
const Product = require('../models/Product');
const authAdmin = require('../middleware/authAdmin'); // Assuming this uses real auth now
const upload = require('../config/cloudinary'); // <-- IMPORT UPLOAD CONFIG
const router = express.Router();

// Add JSON parser for this router
router.use(express.json());

// GET all categories (Public) - Sorted (Ensure slug is returned)
router.get('/', async (req, res) => {
    try {
        // Slug is automatically included unless explicitly excluded
        const categories = await Category.find().sort({ displayOrder: 1, name: 1 });
        res.json(categories);
    } catch (err) {
        console.error("Error fetching categories:", err);
        res.status(500).json({ message: `Error fetching categories: ${err.message}` });
    }
});

// POST create new category (Admin Only)
router.post('/', authAdmin, upload.single('categoryIconImage'), async (req, res) => {
    const { name, iconClass, displayOrder } = req.body;
    
    if (!name) {
        return res.status(400).json({ message: 'Category name is required' });
    }

    try {
        // Create new category - slug will be auto-generated by the model middleware
        const newCategoryData = {
            name,
            iconClass: iconClass || 'fas fa-tag',
            displayOrder: parseInt(displayOrder || '0', 10)
        };

        // Add image URL if uploaded
        if (req.file) {
            console.log('Category Icon Uploaded:', req.file.path);
            newCategoryData.iconImageUrl = req.file.path;
        }

        const newCategory = new Category(newCategoryData);
        await newCategory.save();
        
        console.log(`Category saved: ${newCategory.name} (Slug: ${newCategory.slug})`);
        res.status(201).json(newCategory);
    } catch (err) {
        if (err.code === 11000) {
            const field = Object.keys(err.keyValue)[0];
            console.error(`Duplicate category ${field}:`, err.keyValue[field]);
            return res.status(400).json({ 
                message: `Category ${field} '${err.keyValue[field]}' already exists`
            });
        }
        if (err.name === 'ValidationError') {
            console.error("Validation Error:", err.message);
            return res.status(400).json({ message: err.message });
        }
        console.error("Error creating category:", err);
        res.status(500).json({ message: 'Server error creating category. Check logs.' });
    }
});

// PUT update category (Admin Only)
router.put('/:id', authAdmin, upload.single('categoryIconImage'), async (req, res) => {
    const { name, iconClass, displayOrder } = req.body;
    const updateData = {};

    if (name !== undefined) updateData.name = name;
    if (iconClass !== undefined) updateData.iconClass = iconClass;
    if (displayOrder !== undefined) updateData.displayOrder = parseInt(displayOrder || '0', 10);
    
    // Add/Update image URL if uploaded
    if (req.file) {
        console.log('Category Icon Uploaded for Update:', req.file.path);
        updateData.iconImageUrl = req.file.path;
    }

    if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ message: 'No update data provided.' });
    }

    try {
        // Find and update the category - slug will be auto-generated if name changes
        const category = await Category.findById(req.params.id);
        if (!category) {
            console.warn(`Category not found for update: ${req.params.id}`);
            return res.status(404).json({ message: 'Category not found' });
        }

        // Apply updates
        Object.assign(category, updateData);
        const updatedCategory = await category.save();

        console.log(`Category ${req.params.id} updated successfully. New slug: ${updatedCategory.slug}`);
        res.json(updatedCategory);
    } catch (err) {
        console.error(`Error updating category ${req.params.id}:`, err);
        if (err.code === 11000) {
            const field = Object.keys(err.keyValue)[0];
            return res.status(400).json({ 
                message: `Category ${field} '${err.keyValue[field]}' already exists`
            });
        }
        if (err.name === 'ValidationError') {
            return res.status(400).json({ message: err.message });
        }
        res.status(500).json({ message: 'Server error updating category. Check logs.' });
    }
});

// DELETE category (Admin Only) - No changes needed here for slug
router.delete('/:id', authAdmin, async (req, res) => {
     console.log(`Attempting to delete category ${req.params.id}`);
     try {
        const productCount = await Product.countDocuments({ category: req.params.id });
        if (productCount > 0) {
            console.warn(`Attempt to delete category ${req.params.id} failed: ${productCount} products found.`);
            return res.status(400).json({ message: `Cannot delete category: ${productCount} product(s) are still using it. Please reassign products first.` });
        }
        const deletedCategory = await Category.findByIdAndDelete(req.params.id);
        if (!deletedCategory) {
             console.warn(`Category not found for deletion: ${req.params.id}`);
            return res.status(404).json({ message: 'Category not found' });
        }
        console.log(`Category ${req.params.id} deleted successfully.`);
        res.status(200).json({ message: 'Category deleted successfully' });
    } catch (err) {
        console.error(`Error deleting category ${req.params.id}:`, err);
        res.status(500).json({ message: 'Server error deleting category. Check logs.' });
    }
});

// GET category by slug with its products (Public)
router.get('/:slug', async (req, res) => {
    try {
        console.log(`Fetching category by slug: ${req.params.slug}`);
        const category = await Category.findOne({ slug: req.params.slug });
        
        if (!category) {
            console.warn(`Category not found for slug: ${req.params.slug}`);
            return res.status(404).json({ message: 'Category not found' });
        }
        
        // Fetch products for this category
        const products = await Product.find({ category: category._id })
            .sort({ displayOrder: 1, name: 1 })
            .populate('category', 'name slug iconClass');
        
        // Calculate min and max prices
        let minPrice = 0;
        let maxPrice = 0;
        if (products.length > 0) {
            const numericPrices = products.map(p => p.price).filter(p => typeof p === 'number');
            if (numericPrices.length > 0) {
                minPrice = Math.min(...numericPrices);
                maxPrice = Math.max(...numericPrices);
            }
        }
        
        // Return combined data
        res.json({
            categoryId: category._id,
            categoryName: category.name,
            slug: category.slug,
            iconClass: category.iconClass || 'fas fa-tag',
            iconImageUrl: category.iconImageUrl,
            displayOrder: category.displayOrder,
            products: products,
            minPrice: minPrice,
            maxPrice: maxPrice
        });
    } catch (err) {
        console.error(`Error fetching category by slug ${req.params.slug}:`, err);
        res.status(500).json({ message: `Server error fetching category: ${err.message}` });
    }
});

module.exports = router;