// routes/categories.js
const express = require('express');
const Category = require('../models/Category');
const Product = require('../models/Product');
const authAdmin = require('../middleware/authAdmin'); // Assuming this uses real auth now
const router = express.Router();

// GET all categories (Public) - Sorted (Ensure slug is returned)
router.get('/', async (req, res) => {
    try {
        // Slug is automatically included unless explicitly excluded
        const categories = await Category.find().sort({ displayOrder: 1, name: 1 });
        res.json(categories);
    } catch (err) {
        console.error("Error fetching categories:", err);
        res.status(500).json({ message: `Error fetching categories: ${err.message}` });
    }
});

// POST create new category (Admin Only)
router.post('/', authAdmin, async (req, res) => {
    // Slug is now generated by the pre-validate middleware in the model
    const { name, iconClass, displayOrder, slug } = req.body; // Allow optional manual slug override
    if (!name) return res.status(400).json({ message: 'Category name required' });

    try {
        const newCategoryData = {
            name,
            iconClass: iconClass || 'fas fa-tag',
            displayOrder: displayOrder || 0
        };
        // If a slug was manually provided, use it (it will skip middleware generation)
        if (slug) {
            newCategoryData.slug = slug.toLowerCase().trim();
        }

        const newCategory = new Category(newCategoryData);
        await newCategory.save(); // Middleware will generate slug if not provided
        console.log(`Category saved: ${newCategory.name} (Slug: ${newCategory.slug})`);
        res.status(201).json(newCategory);
    } catch (err) {
         if (err.code === 11000) { // Duplicate key error
            const field = Object.keys(err.keyValue)[0];
            console.error(`Duplicate category ${field}:`, err.keyValue[field]);
            return res.status(400).json({ message: `Category ${field} '${err.keyValue[field]}' already exists`});
         }
         if (err.name === 'ValidationError') {
            console.error("Validation Error:", err.message);
            return res.status(400).json({ message: err.message });
         }
         console.error("Error creating category:", err);
         res.status(500).json({ message: 'Server error creating category. Check logs.' });
    }
});

// PUT update category (Admin Only)
router.put('/:id', authAdmin, async (req, res) => {
    console.log(`Updating category ${req.params.id} with data:`, req.body);
    const { name, iconClass, displayOrder, slug } = req.body; // Allow updating slug
    const updateData = {};

    if (name !== undefined) updateData.name = name;
    // If name changes, slug *might* be regenerated by middleware if slug isn't also provided
    if (slug !== undefined) updateData.slug = slug.toLowerCase().trim(); // Allow manual slug update
    if (iconClass !== undefined) updateData.iconClass = iconClass;
    if (displayOrder !== undefined) updateData.displayOrder = parseInt(displayOrder || '0', 10);

    if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ message: 'No update data provided.' });
    }

    try {
        // Find the category first to let middleware run correctly if name changed without slug change
        const category = await Category.findById(req.params.id);
        if (!category) {
             console.warn(`Category not found for update: ${req.params.id}`);
            return res.status(404).json({ message: 'Category not found' });
        }

        // Apply updates
        Object.assign(category, updateData);

        const updatedCategory = await category.save(); // This will trigger pre-validate if name changed

        console.log(`Category ${req.params.id} updated successfully. New slug: ${updatedCategory.slug}`);
        res.json(updatedCategory);
    } catch (err) {
        console.error(`Error updating category ${req.params.id}:`, err);
         if (err.code === 11000) { const field = Object.keys(err.keyValue)[0]; return res.status(400).json({ message: `Category ${field} '${err.keyValue[field]}' already exists`}); }
         if (err.name === 'ValidationError') { return res.status(400).json({ message: err.message }); }
        res.status(500).json({ message: 'Server error updating category. Check logs.' });
    }
});


// DELETE category (Admin Only) - No changes needed here for slug
router.delete('/:id', authAdmin, async (req, res) => {
     console.log(`Attempting to delete category ${req.params.id}`);
     try {
        const productCount = await Product.countDocuments({ category: req.params.id });
        if (productCount > 0) {
            console.warn(`Attempt to delete category ${req.params.id} failed: ${productCount} products found.`);
            return res.status(400).json({ message: `Cannot delete category: ${productCount} product(s) are still using it. Please reassign products first.` });
        }
        const deletedCategory = await Category.findByIdAndDelete(req.params.id);
        if (!deletedCategory) {
             console.warn(`Category not found for deletion: ${req.params.id}`);
            return res.status(404).json({ message: 'Category not found' });
        }
        console.log(`Category ${req.params.id} deleted successfully.`);
        res.status(200).json({ message: 'Category deleted successfully' });
    } catch (err) {
        console.error(`Error deleting category ${req.params.id}:`, err);
        res.status(500).json({ message: 'Server error deleting category. Check logs.' });
    }
});

module.exports = router;